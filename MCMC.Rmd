---
title: "North Korea COVID-19 "
author: Jong-Hoon Kim
date: March 22, 2005
output:
  md_document:
    variant: markdown_github
editor_options: 
  chunk_output_type: console
---

```{r global_options, echo=F}
knitr::opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE)
```

### Package install
```{r}
# remove.packages("COVID19NorthKorea")
# When earlier installation causes an issue, deleting the package folder under, C:\Users\jonghoon.kim\AppData\Local\R\win-library\4.2, solved.
# devtools::install()
# library(COVID19NorthKorea)
# devtools::load_all() #Ctrl-Shift-L
```

### Data
```{r}
# overall covid data
datall <- readRDS("data/covid_by_province_20230213.rds")# population by province - used to set the initial province-specific population size
pop <- readRDS("data/pop_by_province_20230213.rds")# covid case by province
covid <- readRDS("outputs/covid_by_province_20230213.rds")
```

### BayesianTools package
```{r}
devtools::load_all()
pop <- readRDS("data/pop_by_province_20230213.rds")
dat <- readRDS("data/covid_overall_20230122.rds")

# Number of people who were already symptomatic before the first case
# was officially reported
unreported <- dat$cumul_symptomatic[1] - dat$symptomatic[1] 

PARAMETERS <- initialize_params(pop=sum(pop$Total))
OBS <- c(unreported, dat$symptomatic[1:PARAMETERS$obslength])  
# model_name <- "sepiar_euler"
model_name <- "sepiar_stoch"
PARAMETERS$model <- eval(parse(text=model_name))
# PARAMETERS$model <- sepiar_stoch

# the following does not account for 
# loglik <- function(pars) {
#   daily_inc <- daily_incidence(pars=pars)
#   if (ncol(daily_inc) > 1){
#     stop("More than one column in the daily incidence output")
#   }
#   p1 <- round(pars[1])
#   model <- daily_inc[(p1+1):nrow(daily_inc), 1]
#   loglikelihood <- sum(dpois(OBS, model, log=TRUE))
#   
#   return(loglikelihood)
# }

loglik <- function(pars) {
  daily_inc <- daily_incidence(pars=pars)
  if (ncol(daily_inc) > 1){
    stop("More than one column in the daily incidence output")
  }
  p1 <- round(pars[1])
  model <- c(sum(daily_inc[1:p1, 1]), daily_inc[(p1+1):nrow(daily_inc), 1])
  if (any(model < 0)) {
    ll <- -Inf
  } else{
    ll <- sum(dpois(OBS, model, log=TRUE)) http://127.0.0.1:21077/graphics/plot_zoom_png?width=1407&height=826 
  }
  return(ll)
}

# install.packages("BayesianTools")
library(BayesianTools)
setup <- createBayesianSetup(likelihood = loglik, 
                             lower = c(1,  1, -10, 1e-3),
                             upper = c(100,20 ,20, 1))
# settings = list(iterations = 5e7, message = FALSE)
# adapt and use delayed rejection
# settings <- list(iterations = 1e6, adapt=T, DRlevels=1,
#                  gibbsProbabilities = NULL, temperingFunction=NULL,
#                  optimize=F,  message=FALSE)
settings <- list(iterations=1e5, adapt=T, DRlevels=1, 
                 nrChains=4, gibbsProbabilities = NULL,
                 temperingFunction=NULL,
                 optimize=F, message=FALSE)
# 
out <- runMCMC(bayesianSetup=setup, sampler="Metropolis", settings = settings)
saveRDS(out, paste0("outputs/mcmc_", model_name, "_", tstamp(hour=T, minute=T), ".rds"))
plot(out)

# settings <- list(initialParticles=2e3, iterations=1e2, adaptive=F)
# out <- runMCMC(bayesianSetup = setup, sampler = "SMC", settings = settings)
# saveRDS(out, paste0("outputs/smc_", model_name, "_", tstamp(hour=T, minute=T), ".rds"))
# plot(out)

# print(out)
# summary(out)
# summary(out$chain[sample(2.5e5:5e5, 1e4),])
# # tracePlot(out)
# tracePlot(out$chain[sample(2.5e5:5e5, 1e4),])
# correlationPlot(out)
# marginalPlot(out)

```

### Run: using the estimated parameters 
```{r}
devtools::load_all()

dat <- readRDS("data/covid_overall_20230122.rds")
pop <- readRDS("data/pop_by_province_20230213.rds")
fit <- readRDS("outputs/smc_sepiar_stoch_20230329T1505.rds")
nrun <- 200
# (nr=nrow(fit$chain))
(nr=nrow(fit$particles))
set.seed(42)
# pars <- fit$chain[sample(round(nr/2):nr, nrun),1:4]
pars <- fit$particles[sample(1:nr, nrun),1:4]
# hist(pars[,1])
summary(round(pars[,1]))
apply(pars, 2, summary)

PARAMETERS <- params_init(pop=sum(pop$Total))
var <- c("CE","CI")
PARAMETERS$measure_var <- var
PARAMETERS$model <- sepiar_euler
## run_model changes PARAMETERS$measure_var
res <- run_model(pars=pars, var=var)
sim <- summarize_model_output(model_output=res)
```


### Plot: Model vs. data 
```{r}
library(ggplot2)
p <- plot_model_data(model=sim, data=dat, var="symp")
p
ggsave(sprintf("plots/mcmc_fit_%s.png", timestamp()), p, width=3.4*2, height=2.7*2)
p <- plot_model_data(model=sim, data=dat, var="inf")
p
ggsave(sprintf("plots/mcmc_fit_inf_symp_%s.png", timestamp()), p, width=3.4*2, height=2.7*2)
```

### Summary table
```{r}
# devtools::load_all()
# 
# dat <- readRDS("data/covid_overall_20230122.rds")
# pop <- readRDS("data/pop_by_province_20230213.rds")
# 
# fit <- readRDS("outputs/mcmc_sepiar_euler_20230325T0920.rds")
# (nr <- nrow(fit$chain))
# nrun = 200
# pars <- fit$chain[sample(round(nr/2):nr,nrun),]
# # apply(pars, 2, summary)
# 
# PARAMETERS <- params_init(pop=sum(pop$Total))
# var <- c("CE","CI")
# PARAMETERS$measure_var <- var
# PARAMETERS$model <- sepiar_euler

## run_model changes PARAMETERS$measure_var
pars
res <- run_model(pars=pars, var=var)

format_mean_95CI <- function(x, digits) {
    xf <- format(round(x, digits=digits), big.mark=",", trim=TRUE)
    paste0(xf[1], " (", xf[2] , " - ", xf[3], ")")
}

create_summary_table = function(dat,sim,pars,probs=c(0.025, 0.5, 0.975),cfr=0.003) {
  ci <- sim$CI
  ce <- sim$CE
  min_date_start <- dat$date[1] - max(round(pars[,1]))
  sim_date_intro = quantile(round(pars[,1]), probs=probs)
  date_intro_stat = dat$date[1] - sim_date_intro 

  sim_date_intervention = quantile(floor(pars[,3]), probs=probs)
  date_intervention_stat = dat$date[1] + sim_date_intervention 
  
  ci$date <- seq(min_date_start, length.out=nrow(ci), by="day")
## number of case before May 13
  ci_before <- ci[ci$date < dat$date[1],]
  X <- rep(NA, ncol(ci_before)-1)
  for(i in 1:(ncol(ci_before)-1)) {
    X[i] <- sum(ci_before[,i], na.rm=T)  
  }

  case_before_stat = quantile(X, probs=probs)

  ce_before <- ce[ci$date < dat$date[1],]
  X <- rep(NA, ncol(ce_before)-1)
  for(i in 1:(ncol(ce_before)-1)) {
    X[i] <- sum(ce_before[,i], na.rm=T)  
  }
  inf_before_stat = quantile(X, probs=probs)
  
  inf_stat = quantile(apply(ce, 2, sum, na.rm=T), probs=probs)
  
  cidf <- as.data.frame(ci[,1:(ncol(ci)-1)])

  cases <- apply(cidf, 2, sum, na.rm=T)
  case_stat = quantile(cases, probs=probs)
  deaths <- cfr * cases
  death_stat = quantile(deaths, probs=probs)
  
  d=data.frame(matrix(NA, nrow=7, ncol=2))
  names(d)=c("variable", "value")
  
  d$variable[1] = "Date of introduction"
  d$value[1] = format_mean_95CI(date_intro_stat, digits=0)
  d$variable[2] = "Date of Intervention"
  d$value[2] = format_mean_95CI(date_intervention_stat, digits=0)
  
  d$variable[3] = "Case before May 13"
  d$value[3] = format_mean_95CI(case_before_stat, digits=0)
  d$variable[4] = "Infection before May 13"
  d$value[4] = format_mean_95CI(inf_before_stat, digits=0)
  d$variable[5] = "Total symptomatic"
  d$value[5] = format_mean_95CI(case_stat, digits=0)
  d$variable[6] = "Total infections"
  d$value[6] = format_mean_95CI(inf_stat, digits=0) 
  d$variable[7] = "Total deaths"
  d$value[7] = format_mean_95CI(death_stat, digits=0)  
  
  return(d)
}

tab = create_summary_table(dat=dat,sim=res,pars=pars)

data.table::fwrite(tab, paste0("outputs/summary_tab_ode_",tstamp(),".csv"))

sim <- summarize_model_output(model_output = res)
head(sim)
```

### Plot: parameter estimates
how to adjust the horizontal axis to make the plot more enjoyable?
```{r}
library(ggplot2)
fit <- readRDS("outputs/mcmc_sepiar_euler_20230325T0920.rds")
nrun <- 200
(nr=nrow(fit$chain))
set.seed(42)
pars <- fit$chain[sample(round(nr/2):nr, nrun),1:4]

df <- as.data.frame(pars)
names(df) <- c("t1", "R01","t2","R02")
df2 <- df
df2$t1 <- dat$date[1] - df$t1
df2$t2 <- dat$date[1] + df$t2
  
library(GGally)
ggpairs(df2,
        upper = list(continuous = "density"),
        lower = list(combo = "facetdensity"),
        columnLabels = c("italic(t)[1]", "italic(R)[1]", "italic(t)[2]", "italic(R)[2]"),
        labeller = "label_parsed") +
  theme_bw()


ggpairs(df2,
        upper = list(continuous = "density"),
        columnLabels = c("italic(t)[1]", "italic(R)[1]", "italic(t)[2]", "italic(R)[2]"),
        labeller = "label_parsed") +
  theme_bw()

ggpairs(df2,
        columnLabels = c("italic(t)[1]", "italic(R)[1]", "italic(t)[2]", "italic(R)[2]"),
        labeller = "label_parsed") +
  theme_bw()


upperfun <- function(data,mapping){
  ggplot(data = data, mapping = mapping)+
    geom_density2d()
}   

lowerfun <- function(data,mapping){
  ggplot(data = data, mapping = mapping)+
    geom_point()
}  

p <- ggpairs(df2,upper = list(continuous = wrap(upperfun)),
        lower = list(continuous = wrap(lowerfun)), 
        columnLabels = c("italic(t)[1]", "italic(R)[1]", "italic(t)[2]", "italic(R)[2]"),
        labeller = "label_parsed") +
  theme_bw()
p
# ggsave(sprintf("plots/mcmc_params_%s.png", tstamp()), p, width=3.4*2, height=3.4*2)




### Parameter estimation
```{r}
devtools::load_all()
pop <- readRDS("data/pop_by_province_20230213.rds")
dat <- readRDS("data/covid_overall_20230122.rds")

PARAMETERS <- params_init(pop=sum(pop$Total))
OBS <- dat$symptomatic[1:PARAMETERS$obslength]  
PARAMETERS$model <- sepiar_euler

loglik <- function(pars) {
  daily_inc <- daily_incidence(pars=pars)
  if (ncol(daily_inc) > 1){
    stop("More than one column in the daily incidence output")
  }
  p1 <- round(pars[1])
  model <- daily_inc[(p1+1):nrow(daily_inc), 1]
  loglikelihood <- sum(dpois(OBS, model, log=TRUE))
  
  return(loglikelihood)
}

pars <- c(30, 7, 1, 0.7)
for(i in 1:20){
  p <- pars
  p[4] <- i/10
  print(loglik(pars=p))
}

init <- c(70, 7, 1, 0.7)
# fit = optim(init, loglik, method="BFGS",
#             control=list(fnscale=-1, maxit=1000))
fit = optim(init, loglik, method="L-BFGS-B",
            lower = c(0,   1,  -5, 0.1),
            upper = c(100, 20, 10,  1),
            control=list(fnscale=-1, maxit=1000))
# nlminb for the stochastic version?
print(fit)
print(fit$par)

logprior <- function(p){
  # dunif(params[1], 0, 100, log=TRUE)+
  dnorm(p, 1, 20, log=TRUE) # R0
  # dnorm(p, mean=0, sd=5, log=TRUE)
    # dunif(params[4], 0.1, 1, log=TRUE)
}

res <- daily_incidence(pars=fit$par)
plot(1:nrow(res), res$CI)
points(71:(70+length(OBS)), OBS, col=2)

logpost <- function(p) {
  params <- c(70.0000000, p, -1.1101470, 0.7412037)
  loglik(params) + logprior(p)
}

# fit = optim(init, logpost, method="L-BFGS-B",
#             lower = c(1,1,-5,0.1),
#             upper = c(100,20,10,1),
#             control=list(fnscale=-1, maxit=1000))
# print(fit)
# print(fit$par)

# Metropolis-Hastings algorithm
# mh_kernel <- function(logpost, current, loglik, sd=0.2, fac=NULL, verbose=FALSE){
#   if (is.null(fac)) {
#     fac <- rep(1, length(current))
#   }
#   # proposal
#   repeat{
#     prop <- current + fac * rnorm(length(current), 0, sd)
#     if (prop > 1){
#       break
#     }
#   }
#   
#   loglik_prop <- logpost(prop)
#   pr_current_prop <- dnorm(current, mean=prop, sd=sd, log=T)
#   pr_prop_current <- dnorm(prop, mean=current, sd=sd, log=T)
#   A <- loglik_prop - loglik + pr_current_prop - pr_prop_current
#   A <- A * pnorm(current, mean=0, sd=sd) / pnorm(prop, mean=0, sd=sd)
#   if (verbose) {
#     message(paste0("A =", A))
#   }
#   
#   
#   if (runif(1) < A){
#     list(current=prop, loglik=loglik_prop)
#   }
#   else{
#       list(current=current, loglik=loglik)
#   }
# }

# return a kernal with the desired sd
# mh_kernel <- function(logpost, current, loglik, sd=0.2, verbose=FALSE) {
#   sd2 <- sd
#   verb2 <- verbose
#   function(logpost, current, loglik, sd=sd2, fac=NULL, verbose=verb2){
#     if (is.null(fac)) {
#       fac <- rep(1, length(current))
#     }
#     # proposal
#     # select only positive numbers
#     repeat{
#       prop <- current + fac * rnorm(length(current), 0, sd)
#       if (prop > 1){
#         break
#       }
#     }
#     loglik_prop <- logpost(prop)
#     pr_current_prop <- dnorm(current, mean=prop, sd=sd, log=T)
#     pr_prop_current <- dnorm(prop, mean=current, sd=sd, log=T)
#     A <- loglik_prop - loglik + pr_current_prop - pr_prop_current
#     A <- A * pnorm(current, mean=0, sd=sd) / pnorm(prop, mean=0, sd=sd)
#     if (verbose) {
#       message(paste0("A =", A))
#     }
#     if (runif(1) < A){
#       list(current=prop, loglik=loglik_prop)
#     }
#     else{
#         list(current=current, loglik=loglik)
#     }
#   }
# }


# ll <- logpost(params=init)
# x <- init
# for(i in 1:10000){
#   # print(sum(is.na(daily_incidence(pars=x))))
#   print(logpost(params=x))
#   cat("i =", i, "\n")
#   walk <- mh_kernel(logpost=logpost, x=x, loglik=ll, fac=NULL)
#   ll <- walk$loglik
#   x <- walk$x
#   cat(walk$x, ", ")
#   cat(walk$loglik, "\n")
# }
# 

    
mcmc <- function(init, kernel, iters=1000, thin=10, verbose=TRUE) {
    p <- length(init)
    ll <- -Inf
    mat <- matrix(0, nrow = iters, ncol = p)
    colnames(mat) <- names(init)
    x <- init
    ll <- logpost(p=x)
    if (verbose){ 
      message(paste(iters, "iterations"))
    }
    for (i in 1:iters) {
      if (verbose) {
        message(paste(i, ""), appendLF = FALSE)
      }
      for (j in 1:thin) {
        walk <- kernel(logpost, current=x, loglik=ll)
        x <- walk$current
        ll <- walk$loglik
        print(unlist(lapply(x, function(x) paste(x, ""))))
      }
      mat[i, ] = x
    }
    if (verbose) message("Done.")
    mat
}



init <- 1.2
niter <- 1e4
kern <- mh_kernel(current=init, sd=0.0001, verbose=F)
out <- mcmc(init=init, kernel=kern, iters=niter, thin=10, verbose=FALSE)
plot(out, type="l")
summary(out[round(0.5*niter):niter])
hist(out[round(0.5*niter):niter])

mcmcSummary(out)
# image(cor(out)[ncol(out):1,])
# pairs(out[sample(1:10000,1000),],pch=19,cex=0.2)
```


### Parameter estimation  - 2 parameters
```{r}
devtools::load_all()
pop <- readRDS("data/pop_by_province_20230213.rds")
dat <- readRDS("data/covid_overall_20230122.rds")

PARAMETERS <- params_init(pop=sum(pop$Total))
OBS <- dat$symptomatic[1:PARAMETERS$obslength]  
PARAMETERS$model <- sepiar_euler

loglik <- function(params) {
  daily_inc <- daily_incidence(pars=params)
  if (ncol(daily_inc) > 1){
    stop("More than one column in the daily incidence output")
  }
  p1 <- round(params[1])
  model <- daily_inc[(p1+1):nrow(daily_inc), 1]
  loglikelihood <- sum(dpois(OBS, model, log=TRUE))
  
  return(loglikelihood)
}

pars <- c(30, 7, 1, 0.7)
for(i in 1:20){
  p <- pars
  p[4] <- i/10
  print(loglik(params=p))
}

init <- c(70, 7, 1, 0.7)
# fit = optim(init, loglik, method="BFGS",
#             control=list(fnscale=-1, maxit=1000))
fit = optim(init, loglik, method="L-BFGS-B",
            lower = c(0,   1,  -5, 0.1),
            upper = c(100, 20, 10,  1),
            control=list(fnscale=-1, maxit=1000))
print(fit)
print(fit$par)

res <- daily_incidence(pars=fit$par)
plot(1:nrow(res), res$CI)
points(71:(70+length(OBS)), OBS, col=2)

logprior <- function(p){
  dnorm(p[1], mean=20, sd=30, log=TRUE)+
  dnorm(p[2], mean=6, sd=3, log=TRUE) # R0
  # dnorm(p, mean=0, sd=5, log=TRUE)
    # dunif(params[4], 0.1, 1, log=TRUE)
}

logpost <- function(p) {
  params <- c(p[1], p[2], -1.1101470, 0.7412037)
  loglik(params) + logprior(p)
}


# return a kernal with the desired sd
mh_kernel <- function(logpost, current, loglik, sd=0.2, fac=NULL, verbose=FALSE) {
  sd2 <- sd
  verb2 <- verbose
  fac2 <- fac
  if (is.null(fac2)) {
    fac2 <- rep(1, length(current))
  }
  function(logpost, current, loglik, sd=sd2, fac=fac2, verbose=verb2){
    # proposal
    
    repeat{
      prop <- current + fac * rnorm(length(current), 0, sd)
      if (prop[1] > 1 & prop[2] > 0){# select only positive numbers and R0 > 1
        break
      }
    }
    loglik_prop <- logpost(prop)
    pr_current_prop <- sum(dnorm(current, mean=prop, sd=sd, log=T))
    pr_prop_current <- sum(dnorm(prop, mean=current, sd=sd, log=T))
    A <- loglik_prop - loglik + pr_current_prop - pr_prop_current
    ratio <- exp(sum(pnorm(current, mean=0, sd=sd,log=T))) / exp(sum(pnorm(prop, mean=0, sd=sd, log=T)))
    A <- A * ratio
    if (verbose) {
      message(paste0("A =", A))
    }
    if (runif(1) < A){
      list(current=prop, loglik=loglik_prop)
    }
    else{
        list(current=current, loglik=loglik)
    }
  }
}


init <- c(50,1.2)
niter <- 1e5
kern <- mh_kernel(current=init, sd=0.1, fac=c(5,1), verbose=F)
out <- mcmc(init=init, kernel=kern, iters=niter, thin=1, verbose=FALSE)
library(tidyverse)
out %>% 
  as.data.frame() %>%
  mutate(t = 1:nrow(out)) %>% 
  pivot_longer(cols=1:2, names_to="parameters") %>% 
  ggplot() +
  geom_line(aes(t, value))+
  facet_wrap(~parameters, scale="free_y")+
  theme_bw()

plot(out, type="l")
summary(out[round(0.5*niter):niter])
hist(out[round(0.5*niter):niter])

## BayesianTools package 

# iter = 10000
```

## Bayesian estimation using log-likelihood
The following codes were downloaded from the following website:
https://github.com/darrenjw/logreg/blob/main/R/fit-bayes.R

```{r}
# create data set
if (!require("pacman")) install.packages("pacman")
pacman::p_load("MASS", "arrow")

write_parquet(Pima.tr, file.path("data/", "pima.parquet"))

## Also save in a simple text format for primitive languages...
write.table(Pima.tr, file.path("data/", "pima.data"),
            row.names=FALSE, col.names=FALSE, quote=FALSE)

## eof

if (!require("pacman")) install.packages("pacman")
pacman::p_load("arrow", "smfsb")

df = read_parquet(file.path("data", "pima.parquet"))
print(head(df))
p = dim(df)[2]
y = df[, p]
y = as.integer(y)-1
X = as.matrix(df[, -p])
X = cbind(Int=1, X)
print(y[1:6])
print(head(X))

ll = function(beta)
    sum(-log(1 + exp(-(2*y - 1)*(X %*% beta))))

init = rnorm(p, 0.1)
names(init) = colnames(X)

print("MLE to start with:")
fit = optim(init, ll, method="BFGS", control=list(fnscale=-1, maxit=1000))
print(fit)
print(fit$par)

lprior = function(beta)
    dnorm(beta[1], 0, 10, log=TRUE) + sum(dnorm(beta[-1], 0, 1, log=TRUE))

lpost = function(beta) ll(beta) + lprior(beta)

print("MAP next:")
fit = optim(init, lpost, method="BFGS", control=list(fnscale=-1, maxit=1000))
print(fit)
print(fit$par)

print("Next, MH")

mhKernel = function(logPost, rprop, dprop = function(new, old, ...) { 1 })
    function(x, ll) {
        prop = rprop(x)
        llprop = logPost(prop)
        a = llprop - ll + dprop(x, prop) - dprop(prop, x)
        if (log(runif(1)) < a)
            list(x=prop, ll=llprop)
        else
            list(x=x, ll=ll)
    }
    
mcmc = function(init, kernel, iters = 10000, thin = 10, verb = TRUE) {
    p = length(init)
    ll = -Inf
    mat = matrix(0, nrow = iters, ncol = p)
    colnames(mat) = names(init)
    x = init
    if (verb) 
        message(paste(iters, "iterations"))
    for (i in 1:iters) {
        if (verb) 
            message(paste(i, ""), appendLF = FALSE)
        for (j in 1:thin) {
            pair = kernel(x, ll)
            x = pair$x
            ll = pair$ll
            }
        mat[i, ] = x
        }
    if (verb) 
        message("Done.")
    mat
}

pre = c(10.0,1,1,1,1,1,5,1)
out = mcmc(fit$par, mhKernel(lpost, function(x) x + pre*rnorm(p, 0, 0.02)), thin=1000)
mcmcSummary(out)
image(cor(out)[ncol(out):1,])
pairs(out[sample(1:10000,1000),],pch=19,cex=0.2)
```



### Fit for each region
```{r fit_region}
devtools::load_all()
pop <- readRDS("data/pop_by_province_20230213.rds")
dat <- readRDS("data/covid_by_province_20230213.rds")

replace_NA_with_previous <- function(x){
  for(j in 2:length(x)){   
    x[j] <- ifelse(is.na(x[j]), x[j-1], x[j]) 
  }
  return (x)
}

library(EasyABC)
prior <- list(c("unif",5,150), c("unif",1,20), 
              c("unif",-5,10), c("unif",0.1,2))

nsim <- 50
alpha <- 0.8
tol <- 8
nrep <- 10

timelim <- 10*60 # 10 minutes
# PARAMETERS
model <- sepiar_erlang_stoch
measure_var <- "CI"
erlang <- TRUE  
obslength <- 70

for(i in 1:nrow(pop)){
  d <- dat[dat$province == pop$Province_Korean[i],]
  d$day <- 0:(nrow(d)-1)
  # is this a reasonable assumption
  case_before <- d$`치료중 환자수`[1] + d$`당일 완쾌자수`[1] - d$`당일 발생자수`[1] 
  sum_stat_obs <- c(case_before, d$case[1:obslength])
  sum_stat_obs <- replace_NA_with_previous(sum_stat_obs)
  
  # set the global variables ------------------
  # initial population size by region
  pop_prov <- get_population_size(region = pop$province_clean[i])
  PARAMETERS <- params_init(I0=3, pop=pop_prov, erlang=erlang)
  PARAMETERS$model <- model
  PARAMETERS$measure_var <- measure_var
  PARAMETERS$obslength <- obslength
  # -----------------------------------------------
  tol <- 10
  
  for (s in 1:9) {
    cat("seed =", s, "\n")
    set.seed(s)
    res <- run_with_timelimit(timelim, ABC_sequential(method="Delmoral",
                            model=get_sum_stat,
                            prior=prior, nb_simul=nsim,                            summary_stat_target=sum_stat_obs, 
                            alpha=alpha,
                            tolerance_target=tol, verbose=F, M=nrep))
      
    tstamp <- timestamp(hour=T, minute=T, second=T)
    saveRDS(res, 
            sprintf("outputs/abc_erlang_alpha_%s_tol_%s_seed_%s_%s_%s.rds", alpha, tol, s, pop$province_clean[i], tstamp))
    
    if (is.null(res)) break;
    
    tol <- tol - 1
  }
}

```



### Parameters

```{r}
fls <- list.files("outputs/", pattern="^abc_region_overall_erlang_FALSE_alpha_0.9_tol_.*_20230224.rds$", full.names = T)

library(stringr)
str_extract(fls[1], ".*tol_[0-9+].*_seed.*")

number <- str_extract(fls[1], "(?<=tol\\_)\\d+\\.\\d+")

extract_tol <- function(x){
  str_extract(x, "(?<=tol\\_)\\d+\\.\\d+")
}
tols <- unlist(lapply(fls, function(x) extract_tol(x)))
tols <- as.double(tols)
# tols <- tols[order(tols)]
q20 <- quantile(tols, probs=0.20)
fls[which(tols < q20)]
```




