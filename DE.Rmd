---
title: "Differential evolution"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

### Epidemic curve by region
```{r}
library(COVID19NorthKorea)
dlist <- rio::import_list("inst/extdata/(2022-0811)_코로나19_조선중앙TV_보도_현황표_시도별_일일유열자.xlsx")
nm <- names(dlist)[2:length(dlist)]
caselist <- vector("list", length(nm))
for (i in 1:length(nm)) {
  # df <- data.frame(case = dlist[[i+1]]$`당일 발생자수`)
  df <- dlist[[i+1]]
  # add a few columns to easier management and plotting
  df$case <- dlist[[i+1]]$`당일 발생자수`
  df$date <- extract_dates(dlist[[i+1]]$기준시)
  df$province <- nm[i]
  caselist[[i]] <- df
}

df <- do.call("rbind", caselist)

# saveRDS(df, paste0("outputs/covid_epideimc_by_province_", tstamp(),".rds"))

# library(ggplot2)
# p<-ggplot(df, aes(date, case))+
#   geom_col(fill="brown", alpha=0.5)+
#   theme_bw() +
#   labs(x="", y="Symptomatic case") +
#   facet_wrap(~province)
# p
# ggsave(sprintf("plots/epidemic_curve_%s.png", tstamp()), p, width=3.4*3, height=2.7*3)

# attack rates
library(dplyr)
df %>%
  group_by(province) %>%
  summarize(recovered = sum(`당일 완쾌자수`, na.rm=T), 
            deaths = sum(`당일 사망자 수`, na.rm=T),
            inf = recovered + deaths) -> df_prov 
                    
df_prov$Province_Korean = df_prov$province

pop = POP[,c("Total", "Province_Korean", "Province")]
df_prov = left_join(df_prov, pop, by="Province_Korean")
df_prov$attack_rate = 100 * df_prov$inf / df_prov$Total

# Alternative
# 개성 = 황해북도 https://namu.wiki/w/%EA%B0%9C%EC%84%B1%EC%8B%9C
# 나선 = 함경북도 https://namu.wiki/w/%EB%9D%BC%EC%84%A0%EC%8B%9C?from=%EB%82%98%EC%84%A0%EC%8B%9C
df_prov[df_prov$province == "황북","inf"] = df_prov[df_prov$province == "황북","inf"] +  df_prov[df_prov$province == "개성","inf"] 
df_prov[df_prov$province == "함북","inf"] = df_prov[df_prov$province == "함북","inf"] +  df_prov[df_prov$province == "나선","inf"]
df_prov$attack_rate = 100 * df_prov$inf / df_prov$Total

# shapefile ggplot2 plotting guide
# https://rstudio-pubs-static.s3.amazonaws.com/280176_81148aa4c2024d6ca6e9d21598a3e41f.html

dprk = rgdal::readOGR("inst/extdata/gadm41_PRK_shp", "gadm41_PRK_1")
dprk@data$name_kor = c("자강","함북","함남","황북","황남","개성","강원","강원","평북","평남","평양","나선","양강","평북")
dprk@data$AR = NA
nm = dprk@data$name_kor
for (n in nm){
  dprk@data[dprk@data$name_kor == n,]$AR = df_prov[df_prov$Province_Korean == n,]$attack_rate
}
dprk@data[dprk@data$name_kor  == "개성",]$AR =
  df_prov[df_prov$Province_Korean == "황북",]$attack_rate
dprk@data[dprk@data$name_kor  == "나선",]$AR =
  df_prov[df_prov$Province_Korean == "함북",]$attack_rate

dprk_df <- broom::tidy(dprk, region = "AR")
head(dprk_df)
dprk_df$id <- as.double(dprk_df$id) # attack rate

library(RColorBrewer)
map <- ggplot(data=dprk_df) +
  geom_polygon(aes(x = long, y = lat, group = group, fill=id),
            color = 'black', linewidth = 0.5) +
  scale_fill_gradientn(colors = brewer.pal(9, "YlOrBr"),
                       limits = c(0, max(dprk_df$id)),
                       breaks = seq(0, max(dprk_df$id), 5),
                       "Attack rate (%)")+
  coord_equal() +
  theme_map(legend_position = c(0.9, 0.3)) +
  theme(legend.title = element_text(size=12),
        legend.text = element_text(size=12))

# ggsave(paste0("plots/ar_", tstamp(), ".png"),
#          map, width=7.4, height=7.4, units="in")



# df_prov$province_shape = c("Kangwŏn-do", "Kaesŏng", "Rasŏn", "P'yŏngan-namdo", "Ryanggang", "Chagang-do", "P'yŏngan-namdo", "P'yŏngan-bukto","P'yŏngyang", "Hamgyŏng-namdo", "Hamgyŏng-bukto", "Hwanghae-namdo","Hwanghae-bukto", "P'yŏngan-bukto")


# library(raster)
# # dprk = shapefile("inst/extdata/gadm41_PRK_shp/gadm41_PRK_1.shp")
# 
# shp = rgdal::readOGR("inst/extdata/gadm41_PRK_shp", "gadm41_PRK_1")
# map <- ggplot() + 
#   geom_polygon(data = dprk,
#                aes(x = long, y = lat, group = group),
#                colour = "black", fill = NA) +
#   theme_map()
# 
# shp_df <- broom::tidy(shp, region = "NAME_1")
# ## Regions defined for each Polygons
# cnames <- aggregate(cbind(long, lat) ~ id, data=shp_df, FUN=mean)
# map + 
#   geom_text(data = cnames, aes(x = long, y = lat, label = id), size = 4) +
#   theme_map()
# 



# library(rgdal)     # R wrapper around GDAL/OGR
#   # for general plotting
# library(ggmap)    # for fortifying shapefiles

# Now the shapefile can be plotted as either a geom_path or a geom_polygon.
# Paths handle clipping better. Polygons can be filled.
# You need the aesthetics long, lat, and group.
# map <- 
#   ggplot() +
#   geom_path(data = shape_df, 
#             aes(x = long, y = lat, group = group),
#             color = 'gray', fill="white", size = .2)
# 
# print(map) 
# 
# library(RColorBrewer)
# pal <- brewer.pal(9, "YlOrBr")
# my_palette <- colorRampPalette(pal)
# ggplot(data=shape_df) +
#   geom_path(aes(x = long, y = lat, group = group),
#             color = 'black', linewidth = 0.5) +
#   scale_fill_gradientn(limits = c(0, 50),
#                        breaks = seq(0, 50, 10),
#                        colors = my_palette,
#                        "Attack rate") +
    # geom_polygon(data = shape2, aes(long, lat, group = group),
    #              fill = NA, inherit.aes = FALSE) +
    # geom_path(data = shape2, aes(long, lat, group = group),
    #           color = "black", linewidth = 0.2, inherit.aes = FALSE) +
# 
#     geom_polygon(data = shape, aes(long, lat, group = group),
#                  fill = NA, inherit.aes = FALSE) +
#     geom_path(data = shape, aes(long, lat, group = group),
#               color = "black", linewidth = 0.9, inherit.aes = FALSE) +
    # coord_equal() +
    # theme_map() +
    # theme(legend.title = element_text(size=12),
    #       legend.text = element_text(size=12))


# package sf way
# library(sf)
# # dprk <- sf::read_sf("inst/extdata/gadm41_PRK_shp/gadm41_PRK_1.shp")
# dprk <- st_as_sf(dprk)
# plot(dprk)
# plot(dprk["AR"], main="Attack rate")

# ggplot(data = dprk) +
#   geom_sf(aes(fill=AR))
  
  

# First read in the shapefile, using the path to the shapefile and the shapefile name minus the
# extension as arguments
# shapefile <- readOGR("inst/extdata/gadm41_PRK_shp", "gadm41_PRK_1.shp")
# 
# # Next the shapefile has to be converted to a dataframe for use in ggplot2
# shapefile_df <- fortify(shapefile)
# 
# # Now the shapefile can be plotted as either a geom_path or a geom_polygon.
# # Paths handle clipping better. Polygons can be filled.
# # You need the aesthetics long, lat, and group.
# map <- ggplot() +
# geom_path(data = shapefile_df, 
#           aes(x = long, y = lat, group = group),
#           color = 'gray', fill = 'white', size = .2)
# 
# print(map) 

# df = as.data.frame(dprk)
# df$name_kor = c("자강","함북","함남","황북","황남","개성","강원","강원","평북","평남","평양","나선","양강","평북")
# nm = df$name_kor
# for (n in nm){
#   df[df$name_kor == n,]$AR = df_prov[df_prov$Province_Korean == n,]$attack_rate
# }
#  df[df$name_kor == "개성",]$AR = df_prov[df_prov$Province_Korean == "황북",]$attack_rate
#  df[df$name_kor == "나선",]$AR = df_prov[df_prov$Province_Korean == "함북",]$attack_rate
# 

 
# get_peak <- function(df) {
#   
# }

```

### Time series imputation

```{r}
library(COVID19NorthKorea)
dlist <- rio::import_list("inst/extdata/(2022-0811)_코로나19_조선중앙TV_보도_현황표_시도별_일일유열자.xlsx")
nm <- names(dlist)[2:length(dlist)]
caselist <- vector("list", length(nm))
for (i in 1:length(nm)) {
  # df <- data.frame(case = dlist[[i+1]]$`당일 발생자수`)
  df <- dlist[[i+1]]
  # add a few columns to easier management and plotting
  df$case <- dlist[[i+1]]$`당일 발생자수`
  df$date <- extract_dates(dlist[[i+1]]$기준시)
  df$province <- nm[i]
  caselist[[i]] <- df
}

df <- do.call("rbind", caselist)
names(df)

df1 = df[df$province == "평양",]
ts = df1$`당일 발생자수`
sum(ts, na.rm=T)
library(imputeTS)
ts_im = na_interpolation(x=ts)
sum(ts_im)
region = unique(df$province)
m <- matrix(NA, nrow=73, ncol=length(region)) 
for (i in 1:length(region)) {
  ts = df[df$province == region[i],]$`당일 발생자수`
  # m[,i] <- na_interpolation(ts)
  m[,i] <- na_interpolation(ts, option = "spline")
}
sum(colSums(m))
sum(rowSums(m))
```


### Population density by region 

To explore the association between the population density and the attack rate

Use population per pixel [ppp] (WorldPop https://hub.worldpop.org/geodata/summary?id=27086) and assume that each pixel is around 100m by 100m (at a resolution of 3 arc, i.e., approximately 100m at the equator).
To calculate the population density, sum ppp across the grids that fall on the
region of interest and divide it with the number of grids. 

Two rasters (ppp and ir_*) have the same resolutions and were not aligned perfectly and therefore, resample is done as ppp for 0-1 yo as the reference
```{r}
library(raster)
ppp = raster("inst/extdata/prk_ppp_2020_UNadj.tif")
dprk = rgdal::readOGR("inst/extdata/gadm41_PRK_shp", "gadm41_PRK_1")
dprk@data$name_kor = c("자강","함북","함남","황북","황남","개성","강원","강원",
                       "평북","평남","평양","나선","양강","평북")

density_by_region <- function(polygon, raster){
  nms <- unique(polygon@data$name_kor)
  out <- data.frame(Province_Korean = nms, num_cells=NA, pop_density=NA)
  for (i in 1:length(nms)) {
    poly = polygon[polygon@data$name_kor == out$Province_Korean[i],]
    cells <- raster::extract(raster, poly, df = TRUE, cellnumbers = TRUE)
    out$num_cells[i] <- nrow(cells)
    out$pop[i] <- sum(cells$prk_ppp_2020_UNadj, na.rm=T)
    out$pop_density[i] <- out$pop[i] / out$num_cells[i]
  }
  return(out)
}
den <- density_by_region(dprk, ppp)
names(den) <- c("Province_Korean", names(den)[2:4])
df <- dplyr::left_join(df_prov, den, by="Province_Korean")

# data.table::fwrite(df, "outputs/pop_density_AR.csv")
df <- data.table::fread("outputs/pop_density_AR.csv")

plot(df$pop_density, df$attack_rate)
library(Hmisc)
Hmisc:::rcorr(x=as.matrix(df[,c("pop_density", "attack_rate")]), type="pearson")
```



### Case fatality ratio

```{r}
library(COVID19NorthKorea)
dlist <- rio::import_list("inst/extdata/(2022-0811)_코로나19_조선중앙TV_보도_현황표_시도별_일일유열자.xlsx")
nm <- names(dlist)[2:length(dlist)]
caselist <- vector("list", length(nm))
for (i in 1:length(nm)) {
  # df <- data.frame(case = dlist[[i+1]]$`당일 발생자수`)
  df <- dlist[[i+1]]
  # add a few columns to easier management and plotting
  df$case <- dlist[[i+1]]$`당일 발생자수`
  df$date <- extract_dates(dlist[[i+1]]$기준시)
  df$province <- nm[i]
  caselist[[i]] <- df
}

df <- do.call("rbind", caselist)

# saveRDS(df, paste0("outputs/covid_epideimc_by_province_", tstamp(),".rds"))

# ggsave(sprintf("plots/epidemic_curve_%s.png", tstamp()), p, width=3.4*3, height=2.7*3)

# attack rates
library(dplyr)
df %>%
  group_by(province) %>%
  summarize(recovered = sum(`당일 완쾌자수`, na.rm=T), 
            deaths = sum(`당일 사망자 수`, na.rm=T),
            inf = recovered + deaths) -> df_prov 

x = sum(df_prov$deaths) 
n = x +  sum(df_prov$inf)
p = x / n

se = sqrt(p*(1-p)/n)
ub = p + qnorm(0.975)*se
lb = p - qnorm(0.975)*se
formatC(c(p,lb,ub), format = "e", digits = 6)

prop.test(x=x, n=n, conf.level=.95, correct=FALSE)

library(Hmisc)
binconf(x=x, n=n, alpha=.05)
binconf(x=x, n=n, alpha=.05, method="asymptotic")

# likelihood of observation across varied varied 
p_varied = seq(8e-10, 1e-2, length.out=100)
LL = dbinom(x=x, size=n, prob=p_varied, log=TRUE)
plot(p_varied, LL, type="l")
# plot(p_varied[1:10], LL[1:10], type="l")
abline(v=0.0304, col=2)
abline(v=c(0.0187, 0.0748), col=2, lty=2)
# 1.  Wang C, Liu B, Zhang S, Huang N, Zhao T, Lu Q-B, et al. Differences in incidence and fatality of COVID-19 by SARS-CoV-2 Omicron variant versus Delta variant in relation to vaccine coverage: A world-wide review. Journal of Medical Virology. 2023;95: e28118. doi:10.1002/jmv.28118
# 3.04 (IQR: 1.87–7.48)
cfr_omicron = 0.0304
x_varied = 1:300000
LL = dbinom(x=x_varied, size=n, prob=cfr_omicron, log=TRUE)
plot(x_varied, LL, type="l")
abline(v=x, col=2)
```





### Incidence

```{r}
library(COVID19NorthKorea)
pop <- readRDS("inst/extdata/pop_by_province_20230213.rds")
dat <- readRDS("inst/extdata/covid_by_province_20230213.rds")

prov = unique(dat$province)
i = 1
d <- dat[dat$province == prov[i],]

case_before <- d$`치료중 환자수`[1] + d$`당일 완쾌자수`[1] - d$`당일 발생자수`[1] 
obs <- c(case_before, d$`당일 발생자수`)

PARAMETERS <- initialize_params(obs_length=length(obs))

parm = c(40,6,2,0.6)

y=incidence(pars=parm)

p1 <- round(parm[1])
mod = c(sum(y[1:p1, 1]), y[(p1+1):nrow(y), 1])

plot(mod)

plot(1:nrow(y), y[,1], type='l', xlab="Day", ylab="Daily incidence")
mx = max(obs, )
points((parm[1]+1):length(obs), obs, col=2, ylim=c(0,))
points(seq(parm[1]-1, length(obs)+parm[1]-2), obs, col=2)


```



### Differential evolution

```{r}
devtools::load_all()
PARAMETERS <- initialize_params()
library(RcppDE)
lower = c(1,  1, -10, 1e-3)
upper = c(100,20 ,20, 1) 
set.seed(3)
# Poisson distribution in negloglik
fit <- DEoptim(fn=negloglik, 
               lower=lower, 
               upper=upper,
               control=DEoptim.control(NP=200, itermax=200, trace=FALSE),
               obs=CASES_OBSERVED)

(parm = fit$optim$bestmem)

inc <- incidence(pars=parm)
# p1 <- round(parm[1])
# mod <- c(sum(inc[1:p1, 1]), inc[(p1+1):nrow(inc), 1])
# sim_ <- replicate(2000, rpois(n=length(mod), lambda=mod))
sim_ <- replicate(2000, rpois(n=nrow(inc), lambda=inc[,1]))
sim <- as.data.frame(t(apply(sim_, 1, quantile, probs=c(0.025,0.5,0.975))))

start_date <- DATA$date[1] - parm[1]
end_date <- DATA$date[1] + PARAMETERS$obslength - 1
sim$date <- seq(start_date, end_date, by= "day")

dat = data.frame(date = seq(from=as.Date("2022-05-13"), by="day", length.out=length(CASES_OBSERVED)-1), obs=CASES_OBSERVED[2:81])

library(ggplot2)

library(ggplot2)
sb <- scales::alpha(c("steelblue"), alpha = c(0.2, 0.55, 0.9)) # symptomatic
br <- scales::alpha(c("brown"), alpha = c(0.5)) # data
gr <- scales::alpha(c("darkgreen"), alpha = c(0.2, 0.55, 0.9)) # infection

ggplot(sim, aes(x=date))+
  geom_ribbon(aes(ymax=`97.5%`,ymin=`2.5%`, fill="Model 95% CrI"))+
  geom_line(aes(y=`50%`, color="Model median"), linewidth=1) +
  geom_col(data=dat, aes(x=date, y=obs, fill="Data"),
           inherit.aes = F) +
  scale_fill_manual("", values=c("Model 95% CrI"=sb[1], "Data"=br))+
  scale_color_manual("", values=c("Model median"=sb[3]))+
  labs(x="", y="Case") +
  scale_x_date(date_breaks="2 weeks", date_labels="%Y-%m-%d",
               limits=c(min(sim$date), max(dat$date)))+
  theme_bw()+
  theme(axis.text.x=element_text(angle=60, hjust=1))+
  theme(legend.position=c(0.8,0.5))


-1*negloglik(pars=parm, obs=CASES_OBSERVED)

y=incidence(pars=parm)
p1 <- round(parm[1])
mod = c(sum(y[1:p1, 1]), y[(p1+1):nrow(y), 1])
dpois(CASES_OBSERVED[1], lambda=mod[1], log=TRUE)

plot(1:nrow(y), y[,1], type='l', xlab="Day", ylab="Daily incidence")
points(round(parm[1])+1:length(CASES_OBSERVED), CASES_OBSERVED, col=2)
```

Start with multiple random seeds to increase the chance of reaching the global maximum.

```{r}
# easier to install a package and pass it to use the functions associated with the model
# devtools::install()
library(COVID19NorthKorea)
lower = c(1,  1, -10, 1e-3)
upper = c(100,20 ,20, 1) 

library(parallel)
library(doParallel)
ncores <- detectCores() 

set.seed(42)
cl <- makeCluster(getOption("cl.cores", ncores-2))
doParallel::registerDoParallel(cl)

fits <- 
  foreach(i=1:20,
    .packages = c("COVID19NorthKorea","RcppDE"),
    .inorder=F) %dopar% {
      set.seed(i)
      out <- DEoptim(
        fn = negloglik,
        lower = lower, 
        upper = upper,
        control = DEoptim.control(NP=1000, itermax=1000),
        obs = CASES_OBSERVED)
      return(out)}

parallel::stopCluster(cl)
saveRDS(fits, paste0("outputs/fits_de_", tstamp(),".rds"))
```

### Parametric bootstrapping

```{r}
library(COVID19NorthKorea)
set.seed(42)
# find the best fit and set the estimates as what we looked for
# fits = readRDS("outputs/fits_de_20230426.rds")
fits = readRDS("outputs/fits_de_20230516.rds")
vals = sapply(fits, function(x) x$optim$bestval)
id = which.min(vals)
thetahat = fits[[id]]$optim$bestmem
# best fit was detemined based a single fit
thetahat = parm
# thetahat = fits$min$optim$bestmem
# check by plotting
parm = thetahat
y = incidence(pars=unname(parm)[1:4])
p1 <- round(parm[1])

plot(1:nrow(y), y[,1], type='l', xlab="Day", ylab="Daily incidence")
# points(round(parm[1])+1:length(OBS), OBS, col=2)
points(round(parm[1])+1:length(CASES_OBSERVED), CASES_OBSERVED, col=2)
model = c(sum(y[1:p1, 1]), y[(p1+1):nrow(y), 1])
# Generate synthetic data mod as the mean
nboot <- 2000
# nboot parametric samples of size n; organize in a matrix
bootdata = replicate(nboot, rpois(length(model), lambda=model))
# Compute bootstrap estimates thetahat* and differences delta*
saveRDS(bootdata, paste0("outputs/de_bootdata_", tstamp(),".rds"))
bootdata = readRDS(paste0("outputs/de_bootdata_20230519.rds"))

# plot(1:nrow(bootdata), bootdata[,1], type="l")
# for (i in 2:ncol(bootdata)) {
#   lines(1:nrow(bootdata), bootdata[,i])
# }
# apply(bootdata, 1, mean)
# apply(bootdata, 1, var)

parms = matrix(NA, nrow=5, ncol=nboot)

library(RcppDE)
for (i in 1:nboot) {
  # for (i in 1:200) {
  cat("i =", i, "\n")
  # use parallel with ncores - 2
  outDE = find_min_DE(obs=bootdata[,i],
                      fn=negloglik,
                      iter=10,
                      control=DEoptim.control(NP=200,
                                               itermax=200,
                                               trace=FALSE))
  parms[1:4, i] = outDE$min$optim$bestmem
  parms[5, i] = outDE$min$optim$bestval
}

saveRDS(parms, paste0("outputs/bootstrap_fits_de_", tstamp(),".rds"))
```

### Confidence interval

```{r}
# fits = readRDS("outputs/fits_de_20230426.rds")
# vals = sapply(fits, function(x) x$optim$bestval)
# id = which.min(vals)
# thetahat = fits[[id]]$optim$bestmem
# parms = readRDS("outputs/de_bootstrap_parms_20230427T22.rds")

fits = readRDS("outputs/fits_de_20230512.rds")
thetahat = fits$min$optim$bestmem

parms = readRDS("outputs/bootstrap_fits_de_20230515.rds")
thetahatstar = parms[1:4,]

apply(thetahatstar, 1, quantile, c(0.975, 0.025), na.rm=TRUE)

deltastar = matrix(NA, nrow=nrow(thetahatstar), ncol=ncol(thetahatstar))

for (i in 1:ncol(thetahatstar)) {
  deltastar[c(1,3),i] = round(thetahatstar[c(1,3),i]) - round(thetahat[c(1,3)])
  deltastar[c(2,4),i] = thetahatstar[c(2,4),i] - thetahat[c(2,4)]

}

# Find quantiles and make the bootstrap confidence interval
se = apply(deltastar, 1, quantile, c(0.975, 0.025), na.rm=TRUE)

thetahat[c(2,4)]
(lb = thetahat[c(2,4)] - se[1,c(2,4)])
(ub = thetahat[c(2,4)] - se[2,c(2,4)])
round(thetahat[c(1,3)])
(lb = round(thetahat[c(1,3)]) - se[1,c(1,3)])
(ub = round(thetahat[c(1,3)]) - se[2,c(1,3)])

# thetahat[c(2,4)]
#      par2      par4 
# 5.2853668 0.6324351 
# > (lb = thetahat[c(2,4)] - se[1,c(2,4)])
#      par2      par4 
# 5.2848230 0.6319347 
# > (ub = thetahat[c(2,4)] - se[2,c(2,4)])
#     par2     par4 
# 5.285937 0.632920 
# > round(thetahat[c(1,3)])

```


### By region

```{r}
library(COVID19NorthKorea)
library(DEoptim)

mapfun <- function(x) {
  x[1] <- round(x[1])
  x[3] <- round(x[3])
  return(x)
}

pop <- readRDS("inst/extdata/pop_by_province_20230213.rds")
dat <- readRDS("inst/extdata/covid_by_province_20230213.rds")

prov = unique(dat$province)
i = 1
d <- dat[dat$province == prov[i],]

case_before <- d$`치료중 환자수`[1] + d$`당일 완쾌자수`[1] - d$`당일 발생자수`[1] 
obs <- c(case_before, d$`당일 발생자수`)

  # set the global variables ------------------
  # initial population size by region
PARAMETERS <- initialize_params()

lower = c(1,  1, -10, 1e-3)
upper = c(100,20 ,20, 1) 

set.seed(3)
# Poisson distribution in negloglik
fit <- DEoptim::DEoptim(fn=negloglik, 
               lower=lower, 
               upper=upper,
               control=DEoptim.control(NP=200, itermax=200, trace=FALSE),
               obs=obs, 
               fnMap=mapfun)

parm = fit$optim$bestmem

y=incidence(pars=parm)
p1 <- round(parm[1])
mod = c(sum(y[1:p1, 1]), y[(p1+1):nrow(y), 1])

plot(mod)

plot(1:nrow(y), y[,1], type='l', xlab="Day", ylab="Daily incidence")
mx = max(obs, )
points((parm[1]+1):length(obs), obs, col=2, ylim=c(0,))
points(seq(parm[1]-1, length(obs)+parm[1]-2), obs, col=2)


out <- DEoptim::DEoptim(
  fn = negloglik,
  lower = lower, 
  upper = upper,
  control = DEoptim.control(NP=200,
                            itermax=200,
                            trace=FALSE,
                            parallelType=1,
                            parVar=c("PARAMETERS","OBS"), 
                            packages=c("COVID19NorthKorea")),
  fnMap=mapfun,
  obs = CASES_OBSERVED)



```


















### Stochastic model fitting

```{r}
library(COVID19NorthKorea)
PARAMETERS$model <- sepiar_stoch
library(RcppDE)
parms = find_min_DE(dat=OBS,
                   fn=negloglik,
                   iter=30,
                   control=DEoptim.control(NP=1000,
                                               itermax=1000,
                                               trace=FALSE))
saveRDS(parms, paste0("outputs/de_stoch_parms_", tstamp(),".rds"))
```


### Negative binomial error distribution

```{r}
# library(COVID19NorthKorea)
devtools::load_all()
library(RcppDE)
dist = "negbin"
# you need one additional parameter for the dispersion param (5 params in total)
lower = c(1,  1, -10, 1e-3, 1e-6)
upper = c(200,20 ,50, 1, 1e3) 

set.seed(42)

fit <- DEoptim(fn=negloglik,
               lower=lower,
               upper=upper,
               control=DEoptim.control(
               NP=1000, itermax=1000, trace=FALSE),
               obs=CASES_OBSERVED,
               dist=dist)


# parms = find_min_DE(dat = OBS,
#                    fn = negloglik,
#                    error_dist=error_dist,
#                    lower = lower,
#                    upper = upper,
#                    iter=30,
#                    control=DEoptim.control(NP=1000,
#                                                itermax=1000,
#                                                trace=FALSE))
# saveRDS(parms, paste0("outputs/de_", error_dist, "_parms_", tstamp(),".rds"))


```



### Run the model with observational error
Parameters estimated via parametric bootstrap were 
```{r}
library(COVID19NorthKorea)
set.seed(42)
PARAMETERS <- initialize_params()
fits = readRDS("outputs/fits_de_20230512.rds")
parms = fits$min$optim$bestmem

inc <- incidence(pars=parms)
p1 <- round(parms[1])
mod <- c(sum(inc[1:p1, 1]), inc[(p1+1):nrow(inc), 1])
sim_ <- replicate(2000, rpois(n=length(mod), lambda=mod))
sim <- as.data.frame(t(apply(sim_, 1, quantile, probs=c(0.025,0.5,0.975))))

end_date <- DATA$date[1] + PARAMETERS$obslength - 1
start_date <- end_date - nrow(sim) + 1
sim$date <- seq(start_date, end_date, by= "day")

# run_model changes PARAMETERS$measure_var
# res <- run_model(pars=parms[,1:4], var=var)
# sim <- summarize_model_output(model_output=res)

library(ggplot2)
sb <- scales::alpha(c("steelblue"), alpha = c(0.2, 0.55, 0.9)) # symptomatic
br <- scales::alpha(c("brown"), alpha = c(0.5)) # data
gr <- scales::alpha(c("darkgreen"), alpha = c(0.2, 0.55, 0.9)) # infection

ggplot(sim, aes(x=date))+
  geom_ribbon(aes(ymax=`97.5%`,ymin=`2.5%`, fill="Model 95% CrI")) +
  geom_line(aes(y=`50%`, color="Model median"), linewidth=1) +
  geom_col(data=DATA, aes(x=date, y=symptomatic, fill="Data"), inherit.aes=F)+
  scale_fill_manual("", values=c("Model 95% CrI"= sb[1],"Data"=br))+
  scale_color_manual("", values=c("Model median"=sb[3]))+
  labs(x="", y="Case") +
  scale_x_date(date_breaks="2 weeks", date_labels="%Y-%m-%d",
                   limits=c(min(sim$date), max(DATA$date)))+
  theme_bw()+
  theme(axis.text.x=element_text(angle=60, hjust=1))+
  theme(legend.position=c(0.7,0.5))

# Plot: Model vs. data 
library(ggplot2)
p <- plot_model_data(model=sim, data=DATA, var="symp")
p
# ggsave(sprintf("plots/de_fit_%s.png", tstamp()), p, width=3.4*2, height=2.7*2)
p <- plot_model_data(model=sim, data=DAT, var="inf")
p
# ggsave(sprintf("plots/de_fit_inf_symp_%s.png", tstamp()), p, width=3.4*2, height=2.7*2)

cfr_omicron = 0.0304
# Wang C, Liu B, Zhang S, Huang N, Zhao T, Lu Q-B, et al. Differences in incidence and fatality of COVID-19 by SARS-CoV-2 Omicron variant versus Delta variant in relation to vaccine coverage: A world-wide review. Journal of Medical Virology. 2023;95: e28118. doi:10.1002/jmv.28118

sim$`death_2.5%` = sim$`symp_2.5%`* cfr_omicron
sim$`death_50%` = sim$`symp_50%` * cfr_omicron
sim$`death_97.5%` = sim$`symp_97.5%` * cfr_omicron

# infection
paste0(round(sum(sim$`inf_50%`)), " [95% prediction interval: ", round(sum(sim$`inf_2.5%`)), " to ", round(sum(sim$`inf_97.5%`)), "]")
# deaths
paste0(round(sum(sim$`death_50%`)), " [95% prediction interval: ", round(sum(sim$`death_2.5%`)), " to ", round(sum(sim$`death_97.5%`)), "]")
```


### Run using the estimated parameters
Parameters estimated via parametric bootstrap were 
```{r}
library(COVID19NorthKorea)
set.seed(42)

parms = readRDS(paste0("outputs/de_bootstrap_parms_20230427T22.rds"))
parms = t(parms) # input for the run_model function 
apply(parms, 2, summary)

var <- c("CE","CI")
PARAMETERS$measure_var <- var
PARAMETERS$model <- sepiar_stoch
# run_model changes PARAMETERS$measure_var
res <- run_model(pars=parms[,1:4], var=var)
sim <- summarize_model_output(model_output=res)
# Plot: Model vs. data 
library(ggplot2)
p <- plot_model_data(model=sim, data=DAT, var="symp")
p
# ggsave(sprintf("plots/de_fit_%s.png", tstamp()), p, width=3.4*2, height=2.7*2)
p <- plot_model_data(model=sim, data=DAT, var="inf")
p
# ggsave(sprintf("plots/de_fit_inf_symp_%s.png", tstamp()), p, width=3.4*2, height=2.7*2)

cfr_omicron = 0.0304
# Wang C, Liu B, Zhang S, Huang N, Zhao T, Lu Q-B, et al. Differences in incidence and fatality of COVID-19 by SARS-CoV-2 Omicron variant versus Delta variant in relation to vaccine coverage: A world-wide review. Journal of Medical Virology. 2023;95: e28118. doi:10.1002/jmv.28118

sim$`death_2.5%` = sim$`symp_2.5%`* cfr_omicron
sim$`death_50%` = sim$`symp_50%` * cfr_omicron
sim$`death_97.5%` = sim$`symp_97.5%` * cfr_omicron

# infection
paste0(round(sum(sim$`inf_50%`)), " [95% prediction interval: ", round(sum(sim$`inf_2.5%`)), " to ", round(sum(sim$`inf_97.5%`)), "]")
# deaths
paste0(round(sum(sim$`death_50%`)), " [95% prediction interval: ", round(sum(sim$`death_2.5%`)), " to ", round(sum(sim$`death_97.5%`)), "]")
```



### Grid search
```{r}
tic <- Sys.time()
library(COVID19NorthKorea)
PARAMETERS$model <- sepiar_euler
parm_grids = expand.grid(
  p1 = seq(25, 50, length.out=20),
  p2 = seq(1, 20, length.out=20),
  p3 = seq(-2, 10, length.out=20),
  p4 = seq(0.5, 1, length.out=20),
  p5 = 10)

out = grid_search(parm_grids = parm_grids,
                  dat=OBS,
                  error_dist="negbin")
parms = do.call("rbind", lapply(out, function(x) x$parm))
loglik = do.call("rbind", lapply(out, function(x) x$loglik))
df = cbind(parms, loglik)
saveRDS(df, paste0("outputs/loglik_negbin_", tstamp(),".rds"))

Sys.time() - tic

# df = readRDS(paste0("outputs/loglik_negbin_", tstamp(),".rds"))
# df = readRDS(paste0("outputs/loglik_negbin_20230508T0240.rds"))
df = readRDS(paste0("outputs/loglik_negbin_20230508T0927.rds"))
maxll = max(df[, ncol(df)])
minll = min(df[, ncol(df)])
df[which.max(df[, ncol(df)]), ]
apply(df, 2, summary) 
# [1]   38.18182    6.00000    1.00000    0.60000    1.00000 -828.14408

# m
# select params within maxll - 1 (-1/2 equals one standard deviation)
sdf = df[df[, ncol(df)] > (maxll-2), ]
apply(sdf, 2, summary) 


```


### Model fitting based on deaths
Check the new model to include death
```{r}
# devtools::load_all()
library(COVID19NorthKorea)
# PARAMETERS <- initialize_params()

parm = c(Day1=35.282966, R0=6.0288549, Day2=2.779831, R0_int=0.574270)

-1*negloglik(pars=parm, obs=CASES_OBSERVED, tau=0.01)

y = incidence(c(parm, tau=0.01))
y2 = incidence(c(parm, tau=0.0001))
summary(100*(y2-y)/y)

max_cases = max(c(y[,1], y2[,1], CASES_OBSERVED))

plot(1:nrow(y), y[,1], ylim=c(0,max_cases), type='l', xlab="Day", ylab="Daily incidence")
lines(1:nrow(y2), y2[,1], lty=2)

points(round(parm[1]):nrow(y), CASES_OBSERVED, col=2)

library(RcppDE)
lower = c(1,  1, -10, 1e-3)
upper = c(100,20 ,20, 1)

set.seed(2)
tic = Sys.time()
# Poisson distribution in negloglik
fit <- DEoptim(fn=negloglik, 
               lower=lower, 
               upper=upper,
               control=DEoptim.control(NP=200,itermax=200,trace=FALSE),
               obs=CASES_OBSERVED)

(Sys.time() - tic)

fit$optim$bestmem
fit$optim$bestval 
(parm = fit$optim$bestmem)

-1*negloglik(pars=unname(parm), obs=CASES_OBSERVED, tau=0.01)
# names are par1, par2, ..., which are not compatible with the incidence function
y = incidence(pars=unname(parm))
# or change with the compatible names 
# names(parm) = c("Day1", "R0", "Day2", "R0_int")
# y = incidence(pars=parm)

p1 <- round(parm[1])
mod = c(sum(y[1:p1, 1]), y[(p1+1):nrow(y), 1])
dpois(CASES_OBSERVED[1], lambda=mod[1], log=TRUE)
sum(dpois(CASES_OBSERVED, lambda=mod, log=TRUE))


max_cases = max(c(y[,"CumulSymptomatic"], CASES_OBSERVED))

plot(1:nrow(y), y[,1], ylim=c(0,max_cases), type='l', xlab="Day", ylab="Daily incidence")
points(round(parm[1]):nrow(y), CASES_OBSERVED, col=2)

library(COVID19NorthKorea)
library(RcppDE)

parm_global = 
  find_min_DE(fn=negloglik,
              obs=CASES_OBSERVED,
              iter=10,
              control=DEoptim.control(NP=500,
                                      itermax=500,
                                      trace=FALSE))

saveRDS(parm_global, paste0("outputs/fits_de_", tstamp(), ".rds"))

lapply(parm_global$fits, function(x) x$optim$bestmem)
lapply(parm_global$fits, function(x) x$optim$bestval)
vals = sapply(parm_global$fits, function(x) x$optim$bestval)
idmin = which.min(vals)

parm_global$fits[[idmin]]$optim$bestmem
parm_global$min$optim$bestmem
#       par1       par2       par3       par4 
# 40.3335609  5.2853668  3.5015421  0.6324351 
# p <- readRDS("outputs/param_20230511.rds")
# p$min$optim

```

Fit the deaths
```{r}
devtools::load_all()
parm = c(Day1=35.282966, R0=6.0288549, Day2=2.779831, R0_int=0.574270)
# names(PARAMETERS)
y = incidence(parm, state="Dead")

plot(1:nrow(y), y[,1], type='l', xlab="Day", ylab="Daily death")
points(round(parm[1])+1:length(DEATHS_OBSERVED), DEATHS_OBSERVED, col=2)

library(RcppDE)
lower = c(1,  1, -10, 1e-3)
upper = c(100,20 ,20, 1)

set.seed(42)
tic = Sys.time()
# Poisson distribution in negloglik
fit <- DEoptim(fn=negloglik, 
               lower=lower, 
               upper=upper,
               control=DEoptim.control(NP=500,itermax=500,trace=T),
               state="Dead",
               obs=DEATHS_OBSERVED)

set.seed(42)

lower = c(1,  1, -10, 1e-3, 1e-2)
upper = c(100,30 ,20, 1, 1e2)
tic = Sys.time()
# Poisson distribution in negloglik
fit <- DEoptim(fn=negloglik, 
               lower=lower, 
               upper=upper,
               control=DEoptim.control(NP=500,itermax=500,trace=T),
               dist = "negbin", 
               state="Dead",
               obs=DEATHS_OBSERVED)
(Sys.time() - tic)

fit$optim$bestmem
fit$optim$bestval 
(parm = fit$optim$bestmem)

-1*negloglik(pars=unname(parm), obs=DEATHS_OBSERVED)
# names are par1, par2, ..., which are not compatible with the incidence function
y = incidence(pars=unname(parm)[1:4], state=c("Dead", "CumulSymptomatic"))

p1 <- round(parm[1])
mod = c(sum(y[1:p1, 1]), y[(p1+1):nrow(y), 1])
dpois(DEATHS_OBSERVED[1], lambda=mod[1], log=TRUE)
sum(dpois(DEATHS_OBSERVED, lambda=mod, log=TRUE))

y$day=1:nrow(y)
df = tidyr::pivot_longer(y, cols=-c("day"))
library(ggplot2)
ggplot(df) +
  geom_line(aes(day, value)) +
  facet_wrap(~name, nrow=2, scale="free_y")

max_deaths = max(c(y[,"Dead"], DEATHS_OBSERVED))
    
plot(1:nrow(y), y[,1], type='l', xlab="Day", ylab="Daily deaths", ylim=c(0, max_deaths))
points((round(parm[1])):nrow(y), DEATHS_OBSERVED, col=2)

plot(1:nrow(y), y[,2], type='l', xlab="Day", ylab="Daily cases")
points(round(parm[1])+1:length(CASES_OBSERVED), CASES_OBSERVED, col=2)
```

### DEoptim::DEoptim
```{r}
library(DEoptim)
mapfun <- function(x){
  x[1] <- round(x[1])
  x[3] <- round(x[3])
  return(x)
}

opt <- 
   DEoptim::DEoptim(negloglik,
                    lower=c(1,  1, -10, 1e-3), 
                    upper=c(100,20 ,20, 1),
                    control=DEoptim.control(NP=1000,
                                            itermax=1000,
                                            trace=FALSE,
                                            parallelType=1,
                                            packages=c("COVID19NorthKorea")),
                    fnMap=mapfun,
                    obs=CASES_OBSERVED)
parm = opt$optim$bestmem
y=incidence(pars=parm)
p1 <- round(parm[1])
mod = c(sum(y[1:p1, 1]), y[(p1+1):nrow(y), 1])
negloglik(parm,obs=CASES_OBSERVED)

plot(1:nrow(y), y[,1], type='l', xlab="Day", ylab="Daily incidence")
points(round(parm[1])+1:length(CASES_OBSERVED), CASES_OBSERVED, col=2)

# bootstrapping
model = c(sum(y[1:p1, 1]), y[(p1+1):nrow(y), 1])
# Generate synthetic data mod as the mean
nboot <- 2000
# nboot parametric samples of size n; organize in a matrix
bootdata = replicate(nboot, rpois(length(model), lambda=model))

parms = matrix(NA, nrow=5, ncol=nboot)

for (i in 1:nboot) {
  cat("i =", i, "\n")
  # use parallel with ncores - 2
  outDE <- DEoptim::DEoptim(negloglik,
                    lower=c(1,  1, -10, 1e-3), 
                    upper=c(100,20 ,20, 1),
                    control=DEoptim.control(NP=400,
                                            itermax=400,
                                            trace=FALSE,
                                            parallelType=1,
                                            packages=c("COVID19NorthKorea")),
                    fnMap=mapfun,
                    obs=CASES_OBSERVED)
  
  parms[1:4, i] = outDE$optim$bestmem
  parms[5, i] = outDE$optim$bestval
}

saveRDS(parms, paste0("outputs/bootstrap_fits_de_", tstamp(),".rds"))
```

